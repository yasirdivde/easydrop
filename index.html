<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>EasyDrop P2P — WebRTC File Sharing</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Font Awesome (icons) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

  <!-- PeerJS -->
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <!-- qrcode.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <!-- html5-qrcode -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

  <style>
    .modal { display: none; position: fixed; z-index: 1000; inset: 0; background: rgba(0,0,0,.5); }
    .modal.show { display: flex; align-items: center; justify-content: center; }
    .chat-bubble-sent { background-color: #3b82f6; color: #fff; align-self: flex-end; }
    .chat-bubble-received { background-color: #e5e7eb; color: #1f2937; align-self: flex-start; }
    .queue-item:hover .cancel-btn { opacity: 1; }
    .cancel-btn { opacity: 0.6; transition: opacity .15s ease; }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen">

  <!-- Home -->
  <div id="homeScreen" class="container mx-auto px-4 py-6 max-w-6xl">
    <div class="text-center mb-6">
      <div class="flex items-center justify-center mb-3">
        <i class="fas fa-paper-plane text-4xl text-blue-600"></i>
      </div>
      <h1 class="text-3xl font-bold text-slate-800 mb-1">EasyDrop P2P</h1>
      <p class="text-sm text-slate-600">Direct peer-to-peer file sharing • No file size limits</p>
    </div>

    <div class="text-center mb-5">
      <p class="text-xs text-slate-600 mb-2">Your Device Name</p>
      <div class="flex items-center gap-2 justify-center flex-wrap">
        <input id="deviceNameInput" type="text"
               class="text-base font-bold text-blue-600 bg-slate-100 px-3 py-2 rounded border-2 border-transparent focus:border-blue-500 outline-none max-w-xs"
               value="Device-XXXX"/>
        <button id="saveNameBtn"
                class="bg-green-600 text-white px-3 py-2 rounded-lg hover:bg-green-700"
                title="Save Name">
          <i class="fas fa-save"></i>
        </button>
      </div>
      <div class="mt-3">
        <span id="connectionStatus" class="text-xs text-slate-500">
          <i class="fas fa-circle text-gray-400 mr-1"></i> Waiting...
        </span>
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
      <!-- Direct -->
      <div class="bg-white rounded-2xl shadow-lg p-5">
        <h3 class="text-lg font-bold text-slate-800 mb-4">
          <i class="fas fa-user text-purple-600 mr-2"></i>Direct P2P Connection
        </h3>

        <div class="bg-slate-50 rounded-lg p-3 mb-4">
          <p class="text-xs text-slate-600 mb-1">Your Direct ID</p>
          <div class="flex items-center gap-2">
            <code id="myPeerId" class="flex-1 text-sm font-mono font-bold text-purple-700 bg-slate-200 px-3 py-2 rounded break-all">Initializing...</code>
            <button id="copyMyIdBtn" class="text-purple-600 hover:text-purple-700" title="Copy ID"><i class="fas fa-copy"></i></button>
            <button id="showMyIdQrBtn" class="text-purple-600 hover:text-purple-700" title="Show QR"><i class="fas fa-qrcode"></i></button>
          </div>
        </div>

        <div class="flex flex-col gap-2">
          <input id="remotePeerIdInput" type="text" placeholder="Enter Peer’s Direct ID..." class="flex-1 border border-slate-300 rounded-lg px-4 py-3"/>
          <div class="flex gap-2">
            <button id="scanDirectBtn" class="flex-1 bg-teal-600 text-white px-4 py-3 rounded-lg hover:bg-teal-700">
              <i class="fas fa-camera mr-2"></i>Scan
            </button>
            <button id="connectDirectBtn" class="flex-1 bg-purple-600 text-white px-6 py-3 rounded-lg hover:bg-purple-700">
              <i class="fas fa-link mr-2"></i>Connect
            </button>
          </div>
        </div>
      </div>

      <!-- Room -->
      <div class="bg-white rounded-2xl shadow-lg p-5">
        <h3 class="text-lg font-bold text-slate-800 mb-4">
          <i class="fas fa-users text-blue-600 mr-2"></i>Rooms (Group)
        </h3>

        <div class="flex flex-col gap-2">
          <input id="roomCodeInput" type="text" placeholder="Enter Room Code..." class="flex-1 border border-slate-300 rounded-lg px-4 py-3"/>
          <div class="flex gap-2">
            <button id="scanRoomBtn" class="flex-1 bg-teal-600 text-white px-4 py-3 rounded-lg hover:bg-teal-700">
              <i class="fas fa-camera mr-2"></i>Scan
            </button>
            <button id="joinRoomBtn" class="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700">
              <i class="fas fa-sign-in-alt mr-2"></i>Join
            </button>
          </div>
        </div>

        <div class="text-center my-3 text-slate-500 text-sm">OR</div>

        <button id="createRoomBtn" class="w-full bg-blue-800 text-white px-6 py-3 rounded-lg hover:bg-blue-900">
          <i class="fas fa-plus-circle mr-2"></i>Create New Room
        </button>
      </div>
    </div>

    <div class="text-center mt-8 text-xs text-slate-500 px-4">
      <p><i class="fas fa-shield-alt mr-1"></i>Peer-to-peer • End-to-end encrypted • No file size limits</p>
      <p class="mt-2"><i class="fas fa-server mr-1"></i>Files never stored on server • Direct device transfer</p>
      <p class="mt-2">Created with Coffee By YASIR DIVDE</p>
    </div>
  </div>

  <!-- Transfer Window -->
  <div id="transferWindow" class="hidden container mx-auto px-4 py-6 max-w-7xl">
    <div id="transferHeader" class="bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl shadow-lg p-5 mb-6 text-white"></div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2 flex flex-col gap-6">
        <!-- Send -->
        <div class="bg-white rounded-2xl shadow-lg p-6">
          <h3 id="sendFileTitle" class="text-xl font-bold text-slate-800 mb-4 text-center"></h3>
          <div id="dropZone" class="border-2 border-dashed border-slate-300 rounded-xl p-10 text-center cursor-pointer hover:border-blue-400 transition-all">
            <i class="fas fa-cloud-upload-alt text-5xl text-slate-400 mb-4"></i>
            <p class="text-lg text-slate-700 mb-1">Drag & Drop files here</p>
            <p class="text-sm text-slate-500 mb-4">or</p>
            <label for="fileInput" class="bg-blue-600 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-blue-700 inline-block">
              <i class="fas fa-folder-open mr-2"></i>Browse Files
            </label>
            <input id="fileInput" type="file" class="hidden" multiple />
          </div>
        </div>

        <!-- Queue -->
        <div class="bg-white rounded-2xl shadow-lg p-6">
          <h3 class="text-lg font-bold text-slate-800 mb-4">
            <i class="fas fa-tasks text-blue-600 mr-2"></i>Transfer Queue
          </h3>
          <div id="fileQueue" class="">
            <p class="text-sm text-slate-400 text-center py-4">No active transfers</p>
          </div>
        </div>
      </div>

      <!-- Right Column -->
      <div class="flex flex-col gap-6">
        <!-- Peers (room only) -->
        <div id="peerListContainer" class="bg-white rounded-2xl shadow-lg p-6 hidden">
          <h3 class="text-lg font-bold text-slate-800 mb-4">
            <i class="fas fa-user-friends text-purple-600 mr-2"></i>Connected Peers
          </h3>
          <div id="peerList" class="space-y-2 max-h-40 overflow-y-auto"></div>
        </div>

        <!-- Chat -->
        <div class="bg-white rounded-2xl shadow-lg p-6 flex flex-col" style="height: 50vh; min-height: 300px;">
          <h3 id="chatTitle" class="text-lg font-bold text-slate-800 mb-4"></h3>
          <div id="chatMessages" class="flex-1 overflow-y-auto bg-slate-50 rounded-lg p-3 flex flex-col gap-2 mb-4"></div>
          <div class="flex gap-2">
            <input id="chatInput" type="text" class="flex-1 border border-slate-300 rounded-lg px-4 py-2" placeholder="Type a message..."/>
            <button id="sendChatBtn" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700">
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>

        <!-- History -->
        <div class="bg-white rounded-2xl shadow-lg p-6">
          <h3 class="text-lg font-bold text-slate-800 mb-4">
            <i class="fas fa-history text-purple-600 mr-2"></i>Session History
          </h3>
          <div id="sessionHistory" class="space-y-2 max-h-60 overflow-y-auto">
            <p class="text-sm text-slate-400 text-center py-4">No events yet</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- QR Modal -->
  <div id="qrModal" class="modal">
    <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-sm w-full mx-4 text-center">
      <h3 id="qrModalTitle" class="text-lg font-bold text-slate-800 mb-4"></h3>
      <div id="qrcodeContainer" class="inline-block p-4 bg-white rounded-lg"></div>
      <p id="qrCodeText" class="font-mono text-lg my-2"></p>
      <button id="closeQrBtn" class="mt-4 bg-slate-200 text-slate-700 px-6 py-2 rounded-lg">Close</button>
    </div>
  </div>

  <!-- Scanner Modal -->
  <div id="qrScannerModal" class="modal">
    <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-lg w-full mx-4">
      <div class="flex justify-between items-center mb-4">
        <h3 id="qrScannerTitle" class="text-lg font-bold text-slate-800"></h3>
        <button id="closeScannerBtn" class="text-slate-400 hover:text-slate-600">
          <i class="fas fa-times text-2xl"></i>
        </button>
      </div>
      <div id="qr-reader" class="rounded-lg overflow-hidden w-full"></div>
    </div>
  </div>

  <!-- Receive Modal -->
  <div id="fileReceiveModal" class="modal">
    <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4">
      <div class="text-center mb-6">
        <div class="bg-blue-100 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4">
          <i class="fas fa-file-download text-3xl text-blue-600"></i>
        </div>
        <h3 class="text-xl font-bold text-slate-800 mb-2">Incoming File</h3>
        <p id="fileReceiveSubtext" class="text-sm text-slate-600"></p>
      </div>

      <div class="bg-slate-50 rounded-lg p-4 mb-6 flex items-center gap-3">
        <i id="fileReceiveIcon" class="fas fa-file text-3xl text-blue-600"></i>
        <div class="flex-1 min-w-0">
          <p id="fileReceiveName" class="font-bold text-slate-800"></p>
          <p id="fileReceiveSize" class="text-sm text-slate-500"></p>
          <p id="fileReceiveFrom" class="text-xs text-slate-400 mt-1"></p>
        </div>
      </div>

      <div class="flex gap-3">
        <button id="declineBtn" class="flex-1 bg-slate-200 text-slate-700 px-4 py-3 rounded-lg">
          <i class="fas fa-times mr-2"></i>Decline
        </button>
        <button id="acceptBtn" class="flex-1 bg-blue-600 text-white px-4 py-3 rounded-lg">
          <i class="fas fa-check mr-2"></i>Accept
        </button>
      </div>
    </div>
  </div>

  <script>
  "use strict";

  // ---------- Elements ----------
  const $ = (id) => document.getElementById(id);

  // ---------- Notifications ----------
  function notify(message, type = "info") {
    const colors = {
      success: "bg-green-100 text-green-700 border-green-500",
      error: "bg-red-100 text-red-700 border-red-500",
      warning: "bg-yellow-100 text-yellow-700 border-yellow-500",
      info: "bg-blue-100 text-blue-700 border-blue-500"
    };
    const icons = {
      success: "fa-check-circle",
      error: "fa-exclamation-circle",
      warning: "fa-info-circle",
      info: "fa-info-circle"
    };
    const n = document.createElement("div");
    n.className = `fixed top-4 right-4 border-l-4 p-4 rounded-lg shadow-lg z-50 max-w-sm ${colors[type]}`;
    n.innerHTML = `<div class="flex items-center">
      <i class="fas ${icons[type]} text-xl mr-3"></i>
      <p class="text-sm">${message}</p>
    </div>`;
    document.body.appendChild(n);
    setTimeout(() => n.remove(), 3000);
  }

  // ---------- Utils ----------
  function formatBytes(b) {
    if (!b) return "0 Bytes";
    const k = 1024, sizes = ["Bytes","KB","MB","GB","TB"];
    const i = Math.floor(Math.log(b)/Math.log(k));
    return `${parseFloat((b/Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
  }

  let audioContext = null;
  window.addEventListener("click", () => {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }, { once: true });

  function beep(kind = "info") {
    if (!audioContext) return;
    const o = audioContext.createOscillator();
    const g = audioContext.createGain();
    o.connect(g); g.connect(audioContext.destination);
    o.type = "sine";
    o.frequency.value = kind === "error" ? 220 : (kind === "complete" ? 880 : 440);
    g.gain.setValueAtTime(0.25, audioContext.currentTime);
    g.gain.exponentialRampToValueAtTime(1e-4, audioContext.currentTime + 0.25);
    o.start(); o.stop(audioContext.currentTime + 0.25);
  }

  // ---------- State ----------
  let peer = null;
  let myPeerId = null;        // actual peer id after open
  let preferredPeerId = null; // displayed immediately
  let peerReadyResolve = null;
  let isPeerReady = false;
  const peerReady = new Promise((res) => { peerReadyResolve = res; });

  let myDeviceName = null;

  let connectionMode = null; // "direct" | "room"
  let roomCode = null;
  let isHost = false;

  const connections = {}; // peerId -> DataConnection

  // File transfer
  const pendingReceives = new Map(); // transferId -> { meta, chunks[], size, conn, start }
  const sendQueue = []; // [{ baseId, file }]
  let currentSend = null; // { baseId, file }

  // Throughput tuning (larger and pipelined)
  const CHUNK_SIZE = 2 * 1024 * 1024; // 2 MiB
  const WINDOW_SIZE = 12;             // up to 12 inflight

  // Per-recipient send states
  const sendStates = new Map(); // transferKey -> { baseId, peerId, file, conn, start, nextIndex, totalChunks, inFlight, ackedCount, ackedBytes }
  const groupSendTracker = new Map(); // baseId -> { targets:Set, accepted:Set, rejected:Set, completed:Set }

  // QR
  let html5QrCode = null;
  let qrScannerMode = null; // "direct" | "room"
  let qrScanLocked = false; // prevent duplicates

  // ---------- Peer config ----------
  const peerConfig = {
    config: {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
      ]
    }
  };

  // ---------- Init ----------
  window.addEventListener("load", initialize);

  function initialize() {
    loadDeviceName();
    bindUI();
    // Immediate ID: pre-generate and show
    preferredPeerId = genId();
    $("myPeerId").textContent = preferredPeerId;
    setupPeer(preferredPeerId);
  }

  function genId() {
    return "EZ-" + Math.random().toString(36).slice(2, 8).toUpperCase();
  }

  function loadDeviceName() {
    const saved = localStorage.getItem("deviceName");
    myDeviceName = saved || `Device-${Math.random().toString(36).slice(2,6).toUpperCase()}`;
    $("deviceNameInput").value = myDeviceName;
  }

  function bindUI() {
    $("saveNameBtn").addEventListener("click", () => {
      const name = $("deviceNameInput").value.trim();
      if (name) {
        myDeviceName = name;
        localStorage.setItem("deviceName", name);
        notify("Device name saved!", "success");
      }
    });

    $("copyMyIdBtn").addEventListener("click", async () => {
      const id = myPeerId || preferredPeerId;
      if (id) {
        await navigator.clipboard.writeText(id);
        notify("Direct ID copied!", "success");
      }
    });

    $("showMyIdQrBtn").addEventListener("click", () => showMyIdQr());

    $("connectDirectBtn").addEventListener("click", connectDirect);
    $("scanDirectBtn").addEventListener("click", () => openQRScanner("direct"));

    $("createRoomBtn").addEventListener("click", createRoom);
    $("joinRoomBtn").addEventListener("click", joinRoom);
    $("scanRoomBtn").addEventListener("click", () => openQRScanner("room"));

    $("closeQrBtn").addEventListener("click", closeQR);
    $("closeScannerBtn").addEventListener("click", closeQRScanner);

    $("sendChatBtn").addEventListener("click", sendChatMessage);
    $("chatInput").addEventListener("keypress", (e) => { if (e.key === "Enter") sendChatMessage(); });

    const dropZone = $("dropZone");
    dropZone.addEventListener("dragover", (e) => {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.add("border-blue-500", "bg-blue-50");
    });
    dropZone.addEventListener("dragleave", (e) => {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove("border-blue-500", "bg-blue-50");
    });
    dropZone.addEventListener("drop", (e) => {
      e.preventDefault(); e.stopPropagation();
      dropZone.classList.remove("border-blue-500", "bg-blue-50");
      if (e.dataTransfer.files && e.dataTransfer.files.length) {
        queueFilesForTransfer(e.dataTransfer.files);
      }
    });
    $("fileInput").addEventListener("change", (e) => {
      if (e.target.files && e.target.files.length) {
        queueFilesForTransfer(e.target.files);
      }
      e.target.value = "";
    });
  }

  // ---------- Peer setup ----------
  function setupPeer(customId) {
    try { if (peer) peer.destroy(); } catch (_) {}

    peer = customId ? new Peer(customId, peerConfig) : new Peer(peerConfig);

    peer.on("open", (id) => {
      myPeerId = id;
      isPeerReady = true;
      if (peerReadyResolve) peerReadyResolve(true);
      $("myPeerId").textContent = id;
      updateStatus("Online", "green");
    });

    peer.on("connection", (conn) => {
      if (!connectionMode) {
        connectionMode = (isHost || (roomCode && roomCode === myPeerId)) ? "room" : "direct";
      }
      handleConnection(conn);
    });

    peer.on("error", (err) => {
      console.error("Peer error:", err);
      // If ID is taken, retry quickly with a new one
      if (String(err?.type || err).includes("unavailable-id")) {
        preferredPeerId = genId();
        $("myPeerId").textContent = preferredPeerId;
        setupPeer(preferredPeerId);
        return;
      }
      const msg = connectionMode === "room"
        ? (isHost ? "Room host error." : "Room not found or unreachable.")
        : "A connection error occurred.";
      notify(msg, "error");
      updateStatus("Error", "red");
    });

    peer.on("disconnected", () => {
      updateStatus("Reconnecting...", "orange");
    });
  }

  function awaitPeerReady(fn) {
    if (isPeerReady) { fn(); return; }
    peerReady.then(() => fn());
  }

  function updateStatus(text, color) {
    const colors = {
      green: "text-green-600",
      red: "text-red-600",
      orange: "text-orange-600",
      gray: "text-slate-500"
    };
    $("connectionStatus").innerHTML =
      `<i class="fas fa-circle ${colors[color] || colors.gray} mr-1"></i>${text}`;
  }

  // ---------- Direct connect ----------
  function connectDirect() {
    connectionMode = "direct";
    isHost = false;
    const remoteId = $("remotePeerIdInput").value.trim();
    if (!remoteId) { notify("Please enter a Direct ID.", "warning"); return; }
    if (remoteId === (myPeerId || preferredPeerId)) {
      notify("Cannot connect to yourself.", "error"); return;
    }
    awaitPeerReady(() => {
      const conn = peer.connect(remoteId, { reliable: true, metadata: { deviceName: myDeviceName } });
      handleConnection(conn);
    });
  }

  // ---------- Rooms ----------
  function createRoom() {
    connectionMode = "room";
    isHost = true;
    roomCode = Math.random().toString(36).toUpperCase().slice(2, 8);
    setupPeer(roomCode);
    // show immediately; connections will populate
    showTransferWindow();
  }

  let isJoiningRoom = false;
  function joinRoom() {
    if (isJoiningRoom) return;
    const code = $("roomCodeInput").value.trim().toUpperCase();
    if (!code) { notify("Please enter a room code.", "warning"); return; }
    connectionMode = "room";
    isHost = false;
    roomCode = code;
    isJoiningRoom = true;
    awaitPeerReady(() => {
      const conn = peer.connect(roomCode, { reliable: true, metadata: { deviceName: myDeviceName } });
      handleConnection(conn);
      setTimeout(() => { isJoiningRoom = false; }, 500);
    });
  }

  function leaveRoom() {
    if (connectionMode !== "room") { location.reload(); return; }
    // Inform peers and close connections, then reload host page
    broadcast({ type: "room-closed" });
    Object.values(connections).forEach(c => { try { c.close(); } catch(_) {} });
    setTimeout(() => location.reload(), 300);
  }

  // ---------- Connection lifecycle ----------
  function handleConnection(conn) {
    conn.on("open", () => {
      connections[conn.peer] = conn;
      conn.send({ type: "metadata-sync", deviceName: myDeviceName, mode: connectionMode, roomCode });
      
      closeQRScanner();

      showTransferWindow();
      updatePeerListUI();
    });

    conn.on("data", (data) => { routeData(data, conn); });

    conn.on("close", () => {
      delete connections[conn.peer];
      if (connectionMode === "direct") {
        notify("Peer disconnected.", "info");
        setTimeout(() => location.reload(), 600);
      } else {
        updatePeerListUI();
      }
    });

    conn.on("error", (err) => {
      console.error("Connection error:", conn.peer, err);
      notify("A connection encountered an error.", "error");
    });
  }

  function broadcast(payload, excludePeerId = null) {
    Object.keys(connections).forEach((id) => {
      if (id === excludePeerId) return;
      const c = connections[id];
      if (c && c.open) c.send(payload);
    });
  }

  // ---------- Data router ----------
  function routeData(data, conn) {
    if (!data || typeof data !== "object" || typeof data.type !== "string") return;

    switch (data.type) {
      case "metadata-sync": {
        if (connections[conn.peer]) {
          connections[conn.peer].metadata = { deviceName: data.deviceName };
        }
        if (!connectionMode && data.mode) {
          connectionMode = data.mode;
          roomCode = data.roomCode || roomCode;
        }
        updatePeerListUI();
        showTransferWindow();
        break;
      }

      case "room-closed": {
        notify("Room closed by host.", "warning");
        setTimeout(() => location.reload(), 400);
        break;
      }

      // Chat
      case "chat-message": {
        displayChatMessage(data);
        beep("info");
        break;
      }

      // File sharing
      case "file-request": { onFileRequest(data, conn); break; }
      case "file-accepted": { onFileAccepted(data, conn); break; }
      case "file-rejected": { onFileRejected(data, conn); break; }
      case "file-chunk":   { onFileChunk(data, conn); break; }
      case "file-ack":     { onAck(data, conn); break; }
      case "file-cancel":  { onFileCancel(data, conn); break; }

      default: break;
    }
  }

  // ---------- UI: transfer window ----------
  function showTransferWindow() {
    // *** FIX: Only close QR modal if not a room host, allowing multiple joins ***
    if (!isHost) {
      closeQR();
    }
    $("homeScreen").classList.add("hidden");
    $("transferWindow").classList.remove("hidden");

    const header = $("transferHeader");
    const peerListContainer = $("peerListContainer");

    if (connectionMode === "direct") {
      const remote = Object.values(connections)[0];
      const peerName = remote?.metadata?.deviceName || "Peer";
      header.innerHTML = `
        <div class="flex flex-col md:flex-row items-center justify-between gap-4">
          <div class="flex items-center gap-4">
            <div class="bg-white text-purple-600 w-16 h-16 rounded-full flex items-center justify-center">
              <i class="fas fa-user text-3xl"></i>
            </div>
            <div>
              <h2 class="text-xl md:text-2xl font-bold">Connected to ${peerName}</h2>
              <p class="text-xs opacity-75 font-mono">${remote?.peer || ""}</p>
            </div>
          </div>
          <div>
            <button class="bg-red-500 text-white px-6 py-3 rounded-lg hover:bg-red-600" onclick="location.reload()">
              <i class="fas fa-times mr-2"></i>Disconnect
            </button>
          </div>
        </div>
      `;
      peerListContainer.classList.add("hidden");
      $("sendFileTitle").innerHTML = `<i class="fas fa-paper-plane text-purple-600 mr-2"></i>Send Files`;
      $("chatTitle").innerHTML = `<i class="fas fa-comments text-green-600 mr-2"></i>Direct Chat`;
    } else {
      header.innerHTML = `
        <div class="flex flex-col md:flex-row items-center justify-between gap-4">
          <div class="flex items-center gap-4">
            <div class="bg-white text-blue-600 w-16 h-16 rounded-full flex items-center justify-center">
              <i class="fas fa-users text-3xl"></i>
            </div>
            <div>
              <h2 class="text-xl md:text-2xl font-bold">
                Room Code <span class="font-mono">${roomCode || ""}</span>
              </h2>
              <p class="text-sm opacity-90">Your Name • ${myDeviceName}</p>
            </div>
          </div>
          <div class="flex gap-2">
            <button class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600" onclick="navigator.clipboard.writeText('${roomCode || ""}').then(()=>notify('Room code copied!','success'))">
              <i class="fas fa-copy mr-2"></i>Copy Code
            </button>
            <button class="bg-purple-500 text-white px-4 py-2 rounded-lg hover:bg-purple-600" onclick="showRoomQr()">
              <i class="fas fa-qrcode mr-2"></i>Show QR
            </button>
            <button class="bg-red-500 text-white px-6 py-3 rounded-lg hover:bg-red-600" onclick="leaveRoom()">
              <i class="fas fa-door-open mr-2"></i>Leave Room
            </button>
          </div>
        </div>
      `;
      peerListContainer.classList.remove("hidden");
      $("sendFileTitle").innerHTML = `<i class="fas fa-paper-plane text-blue-600 mr-2"></i>Send Files to Room`;
      $("chatTitle").innerHTML = `<i class="fas fa-comments text-green-600 mr-2"></i>Room Chat`;
      updatePeerListUI();
    }
  }

  function updatePeerListUI() {
    if (connectionMode !== "room") return;
    const container = $("peerList");
    let html = `<div class="p-2 bg-blue-50 rounded-lg text-sm font-bold text-blue-700">${myDeviceName} ${isHost ? "(Host)" : ""}</div>`;
    Object.values(connections).forEach((c) => {
      if (!c || c.peer === myPeerId) return;
      const name = c.metadata?.deviceName || c.peer;
      html += `<div class="flex justify-between items-center p-2 bg-slate-50 rounded-lg text-sm text-slate-700">
        <span>${name}</span>
      </div>`;
    });
    if (!Object.values(connections).filter(c => !!c).length) {
      html += `<p class="text-xs text-slate-400 text-center py-2">You are alone in this room.</p>`;
    }
    container.innerHTML = html;
  }

  // ---------- File send (per-recipient) ----------
  function queueFilesForTransfer(fileList) {
    const files = Array.from(fileList);
    if (!files.length) return;
    if (!Object.keys(connections).length) {
      notify("No one is connected!", "warning"); return;
    }
    for (const file of files) {
      const baseId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
      sendQueue.push({ baseId, file });
      addQueueUI(`pending-${baseId}`, `${file.name}`, true, "Waiting...");
    }
    if (!currentSend) processSendQueue();
  }

  function processSendQueue() {
    if (currentSend || sendQueue.length === 0) return;
    const next = sendQueue.shift();
    const baseId = next.baseId;
    const file = next.file;
    currentSend = { baseId, file };
    removeQueueItemInstant(`pending-${baseId}`);

    const recipients = connectionMode === "direct"
      ? [Object.values(connections)[0]].filter(Boolean)
      : Object.values(connections);

    groupSendTracker.set(baseId, {
      targets: new Set(recipients.map(c => c.peer)),
      accepted: new Set(),
      rejected: new Set(),
      completed: new Set()
    });

    for (const c of recipients) {
      const peerName = c.metadata?.deviceName || c.peer;
      const transferKey = getTransferKey(baseId, c.peer);
      addQueueUI(transferKey, `${file.name} → ${peerName}`, true, "Offering...");
      c.send({
        type: "file-request",
        id: baseId,
        name: file.name,
        size: file.size,
        fileType: file.type,
        senderId: myPeerId || preferredPeerId,
        senderName: myDeviceName
      });
    }
  }

  function getTransferKey(baseId, peerId) { return `${baseId}|${peerId}`; }

  function onFileAccepted(data, conn) {
    if (!currentSend || currentSend.baseId !== data.id) return;
    const baseId = data.id;
    const tracker = groupSendTracker.get(baseId);
    if (tracker) tracker.accepted.add(conn.peer);

    const file = currentSend.file;
    const transferKey = getTransferKey(baseId, conn.peer);
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
    sendStates.set(transferKey, {
      baseId,
      peerId: conn.peer,
      file,
      conn,
      start: Date.now(),
      nextIndex: 0,
      totalChunks,
      inFlight: 0,
      ackedCount: 0,
      ackedBytes: 0
    });
    pumpChunks(transferKey);
  }

  function onFileRejected(data, conn) {
    if (!currentSend || currentSend.baseId !== data.id) return;
    const baseId = data.id;
    const tracker = groupSendTracker.get(baseId);
    if (tracker) {
      tracker.rejected.add(conn.peer);
      tracker.accepted.delete(conn.peer);
    }

    const transferKey = getTransferKey(baseId, conn.peer);
    updateProgressUI(transferKey, undefined, undefined, "Declined");

    if (connectionMode === "direct") {
      notify("Transfer rejected.", "warning");
      finishBaseIfDone(baseId);
      return;
    }
    if (tracker && tracker.rejected.size === tracker.targets.size && tracker.accepted.size === 0) {
      for (const peerId of tracker.targets) {
        removeQueueItemInstant(getTransferKey(baseId, peerId));
      }
      notify("All peers rejected the file.", "warning");
    }
    finishBaseIfDone(baseId);
  }

  function onAck(data, conn) {
    const key = getTransferKey(data.transferId, conn.peer);
    const state = sendStates.get(key);
    if (!state) return;

    state.inFlight = Math.max(0, state.inFlight - 1);
    state.ackedCount += 1;
    const isLast = (data.chunkIndex === state.totalChunks - 1);
    const sizeAck = isLast ? (state.file.size - CHUNK_SIZE * (state.totalChunks - 1)) : CHUNK_SIZE;
    state.ackedBytes += sizeAck;

    const progress = (state.ackedCount / state.totalChunks) * 100;
    const speed = senderSpeedMBps(state);
    const status = connectionMode === "direct"
      ? "Sending..."
      : `Sending to ${state.conn.metadata?.deviceName || state.peerId}`;
    updateProgressUI(key, progress, speed, status);

    if (state.ackedCount >= state.totalChunks) {
      updateProgressUI(key, 100, speed, "Sent!");
      addHistory(`Sent ${state.file.name} (${formatBytes(state.file.size)})`, "send");
      beep("complete");
      const tracker = groupSendTracker.get(state.baseId);
      if (tracker) {
        tracker.completed.add(conn.peer);
        tracker.accepted.delete(conn.peer);
      }
      sendStates.delete(key);
      finishBaseIfDone(state.baseId);
      return;
    }
    pumpChunks(key);
  }

  async function pumpChunks(transferKey) {
    const state = sendStates.get(transferKey);
    if (!state) return;
    const { file, conn } = state;
    while (state.inFlight < WINDOW_SIZE && state.nextIndex < state.totalChunks) {
      const start = state.nextIndex * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const arrayBuffer = await file.slice(start, end).arrayBuffer();
      conn.send({
        type: "file-chunk",
        payload: arrayBuffer,
        transferId: state.baseId,
        chunkIndex: state.nextIndex,
        totalChunks: state.totalChunks,
        name: file.name,
        fileType: file.type,
        size: file.size,
        senderName: myDeviceName
      });
      state.nextIndex += 1;
      state.inFlight += 1;
    }
  }

  function senderSpeedMBps(state) {
    const elapsed = Math.max(0.001, (Date.now() - state.start) / 1000);
    return (state.ackedBytes / 1024 / 1024) / elapsed;
  }

  // When a base file is completely decided and no active streams remain, advance
  function finishBaseIfDone(baseId) {
    const tracker = groupSendTracker.get(baseId);
    if (!tracker) {
      if (currentSend && currentSend.baseId === baseId) {
          currentSend = null;
          processSendQueue();
      }
      return;
    }

    const activeForBase = Array.from(sendStates.keys()).some(k => k.startsWith(`${baseId}|`));
    const decidedCount = tracker.completed.size + tracker.rejected.size;

    if (decidedCount >= tracker.targets.size && !activeForBase) {
      currentSend = (currentSend && currentSend.baseId === baseId) ? null : currentSend;
      groupSendTracker.delete(baseId);
      processSendQueue();
    }
  }

  // ---------- Cancel (sender only) ----------
  function cancelPending(baseId) {
    const idx = sendQueue.findIndex(t => t.baseId === baseId);
    if (idx !== -1) {
      sendQueue.splice(idx, 1);
      removeQueueItemInstant(`pending-${baseId}`);
    }
  }

  function cancelTransfer(transferKey) {
    const [baseId, peerId] = transferKey.split("|");
    const conn = connections[peerId];
    if (conn && conn.open) { conn.send({ type: "file-cancel", id: baseId }); }
    if (sendStates.has(transferKey)) { sendStates.delete(transferKey); }
    updateProgressUI(transferKey, undefined, undefined, "Cancelled");

    const tracker = groupSendTracker.get(baseId);
    if (tracker) {
      tracker.rejected.add(peerId);
      tracker.accepted.delete(peerId);
      // If direct mode, treat as entire send cancellation and finish immediately
      if (connectionMode === "direct") {
        // remove any other UI rows for this baseId
        for (const target of tracker.targets) {
          removeQueueItemInstant(getTransferKey(baseId, target));
        }
        groupSendTracker.delete(baseId);
        if (currentSend && currentSend.baseId === baseId) currentSend = null;
        processSendQueue();
        return;
      }
      // Room mode: continue for others, or finish if everyone decided
      finishBaseIfDone(baseId);
    } else {
      // No tracker (edge): just proceed
      if (currentSend && currentSend.baseId === baseId) currentSend = null;
      processSendQueue();
    }
  }

  // ---------- File receive ----------
  function onFileRequest(meta, conn) {
    if (meta.senderId === (myPeerId || preferredPeerId)) return;

    const iconMap = {
      "jpg": "fa-file-image",
      "jpeg": "fa-file-image",
      "png": "fa-file-image",
      "pdf": "fa-file-pdf",
      "zip": "fa-file-zipper",
      "mp4": "fa-file-video",
      "mp3": "fa-file-audio"
    };
    const ext = (meta.name.split(".").pop() || "").toLowerCase();
    $("fileReceiveSubtext").textContent = connectionMode === "direct"
      ? "A peer wants to send you a file"
      : "A peer in the room wants to send a file";
    $("fileReceiveName").textContent = meta.name;
    $("fileReceiveSize").textContent = formatBytes(meta.size);
    $("fileReceiveFrom").textContent = `From ${meta.senderName || conn.peer}`;
    $("fileReceiveIcon").className = `fas ${iconMap[ext] || "fa-file"} text-3xl text-blue-600`;

    $("fileReceiveModal").dataset.transferId = meta.id;
    $("fileReceiveModal").dataset.fromPeer = conn.peer;
    $("fileReceiveModal").classList.add("show");

    pendingReceives.set(meta.id, {
      meta,
      conn,
      chunks: [],
      receivedSize: 0,
      start: Date.now()
    });
  }

  $("acceptBtn").addEventListener("click", () => {
    const transferId = $("fileReceiveModal").dataset.transferId;
    const p = pendingReceives.get(transferId);
    if (!p) return;
    p.conn.send({ type: "file-accepted", id: transferId, name: p.meta.name });
    addQueueUI(transferId, p.meta.name, false, "Receiving...");
    $("fileReceiveModal").classList.remove("show");
  });

  $("declineBtn").addEventListener("click", () => {
    const transferId = $("fileReceiveModal").dataset.transferId;
    const p = pendingReceives.get(transferId);
    if (!p) return;
    p.conn.send({ type: "file-rejected", id: transferId, name: p.meta.name });
    pendingReceives.delete(transferId);
    addHistory(`Declined ${p.meta.name}`, "decline");
    $("fileReceiveModal").classList.remove("show");
  });

  function onFileChunk(data, conn) {
    const { payload, transferId, chunkIndex, totalChunks, fileType, name, size } = data;
    const p = pendingReceives.get(transferId);
    if (!p) return; // may have been cancelled

    p.chunks[chunkIndex] = payload;
    p.receivedSize += (payload?.byteLength || 0);

    const progress = (p.receivedSize / size) * 100;
    const elapsed = (Date.now() - p.start) / 1000;
    const speedMBps = elapsed > 0 ? (p.receivedSize / 1024 / 1024) / elapsed : 0;

    updateProgressUI(transferId, progress, speedMBps, "Receiving...");
    conn.send({ type: "file-ack", transferId, chunkIndex });

    if (p.chunks.filter(Boolean).length === totalChunks) {
      try {
        const ordered = [];
        for (let i = 0; i < totalChunks; i++) ordered.push(new Uint8Array(p.chunks[i]));
        const blob = new Blob(ordered, { type: fileType || "application/octet-stream" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = name || "download";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);

        updateProgressUI(transferId, undefined, undefined, "Completed!");
        addHistory(`Received ${name} (${formatBytes(size)})`, "receive");
        beep("complete");
      } catch (e) {
        console.error("Complete receive error:", e);
        updateProgressUI(transferId, undefined, undefined, "Error!");
        beep("error");
      } finally {
        pendingReceives.delete(transferId);
      }
    }
  }

  function onFileCancel(data, conn) {
    const id = data.id;
    const p = pendingReceives.get(id);
    if (p) {
      if ($("fileReceiveModal").dataset.transferId === id) {
        $("fileReceiveModal").classList.remove("show");
      }
      pendingReceives.delete(id);
    }
    removeQueueItemInstant(id);
    notify("Sender cancelled the transfer.", "warning");
  }

  // ---------- Queue UI ----------
  function addQueueUI(id, fileName, isSender, initialStatus = null) {
    const q = $("fileQueue");
    if (q.querySelector("p")) q.innerHTML = "";
    const el = document.createElement("div");
    el.id = `transfer-${id}`;
    el.className = "queue-item";
    el.innerHTML = `
      <div class="bg-slate-100 rounded-lg p-3 mb-2">
        <div class="flex items-center justify-between mb-2">
          <span class="text-sm font-medium text-slate-800 break-words" title="${fileName}">${fileName}</span>
          <div class="flex items-center gap-3">
            <span class="text-sm font-medium text-blue-600" id="percent-${id}">0%</span>
            ${isSender ? `<button id="cancel-${id}" class="cancel-btn text-red-600 hover:text-red-700" title="Cancel"><i class="fas fa-times-circle"></i></button>` : ``}
          </div>
        </div>
        <div class="w-full bg-slate-200 rounded-full h-2">
          <div id="bar-${id}" class="bg-blue-600 h-2 rounded-full" style="width:0%"></div>
        </div>
        <div class="flex justify-between text-xs text-slate-600 mt-1">
          <span id="speed-${id}">0.00 MB/s</span>
          <span id="status-${id}">${initialStatus ?? (isSender ? "Offering..." : "Waiting...")}</span>
        </div>
      </div>
    `;
    q.appendChild(el);

    if (isSender) {
      const btn = document.getElementById(`cancel-${id}`);
      if (btn) {
        if (id.startsWith("pending-")) {
          const baseId = id.slice("pending-".length);
          btn.addEventListener("click", () => cancelPending(baseId));
        } else {
          btn.addEventListener("click", () => cancelTransfer(id));
        }
      }
    }
  }

  function updateProgressUI(id, progress, speedMBps, status) {
    const root = document.getElementById(`transfer-${id}`);
    if (!root) return;
    const percentEl = document.getElementById(`percent-${id}`);
    const barEl = document.getElementById(`bar-${id}`);
    const speedEl = document.getElementById(`speed-${id}`);
    const statusEl = document.getElementById(`status-${id}`);

    if (typeof progress === "number") {
      percentEl.textContent = `${Math.round(progress)}%`;
      barEl.style.width = `${progress}%`;
    }
    if (typeof speedMBps === "number") {
      speedEl.textContent = `${speedMBps.toFixed(2)} MB/s`;
    }
    if (typeof status === "string") {
      statusEl.textContent = status;
    }

    if (["Completed!", "Declined", "Error!", "Sent!", "Cancelled"].includes(status)) {
      setTimeout(() => {
        root.remove();
        if (!document.querySelector("[id^='transfer-']")) {
          $("fileQueue").innerHTML = `<p class="text-sm text-slate-400 text-center py-4">No active transfers</p>`;
        }
      }, 2000);
    }
  }

  function removeQueueItemInstant(id) {
    const root = document.getElementById(`transfer-${id}`);
    if (root) root.remove();
    if (!document.querySelector("[id^='transfer-']")) {
      $("fileQueue").innerHTML = `<p class="text-sm text-slate-400 text-center py-4">No active transfers</p>`;
    }
  }

  // ---------- Chat ----------
  function sendChatMessage() {
    const input = $("chatInput");
    const message = input.value.trim();
    if (!message) return;

    const payload = { type: "chat-message", content: message, senderName: myDeviceName };
    if (connectionMode === "direct") {
      const c = Object.values(connections)[0];
      c?.send(payload);
    } else {
      broadcast(payload);
    }
    displayChatMessage({ content: message, senderName: myDeviceName }, true);
    input.value = "";
  }

  function displayChatMessage(data, isSent = false) {
    const box = $("chatMessages");
    const wrapper = document.createElement("div");
    wrapper.className = `flex flex-col ${isSent ? "items-end" : "items-start"}`;
    if (connectionMode === "room") {
      const name = document.createElement("span");
      name.className = "text-xs text-slate-500 mb-1";
      name.textContent = isSent ? "You" : (data.senderName || "Peer");
      wrapper.appendChild(name);
    }
    const bubble = document.createElement("div");
    bubble.className = `p-2 rounded-lg max-w-xs break-words ${isSent ? "chat-bubble-sent" : "chat-bubble-received"}`;
    bubble.textContent = data.content || "";
    wrapper.appendChild(bubble);
    box.appendChild(wrapper);
    box.scrollTop = box.scrollHeight;
    if (!isSent) beep("info");
  }

  // ---------- History (show all file events in detail) ----------
  function addHistory(message, type = "info") {
    if (!["send", "receive", "decline"].includes(type)) return;
    const h = $("sessionHistory");
    const placeholder = h.querySelector("p");
    if (placeholder) placeholder.remove();

    const icons = {
      send: "fa-arrow-up text-blue-600",
      receive: "fa-arrow-down text-green-600",
      decline: "fa-times-circle text-red-500"
    };
    const div = document.createElement("div");
    div.className = "flex items-center gap-3 p-2 bg-slate-50 rounded-lg";
    div.innerHTML = `
      <i class="fas ${icons[type]}"></i>
      <div class="flex-1 min-w-0">
        <p class="text-sm text-slate-800 whitespace-normal break-words">${message}</p>
        <p class="text-xs text-slate-500">${new Date().toLocaleTimeString()}</p>
      </div>
    `;
    h.insertBefore(div, h.firstChild);
  }

  // ---------- QR ----------
  function showMyIdQr() {
    $("qrModalTitle").textContent = "Your Direct ID";
    const container = $("qrcodeContainer");
    container.innerHTML = "";
    new QRCode(container, { text: (myPeerId || preferredPeerId) || "", width: 256, height: 256 });
    $("qrCodeText").textContent = (myPeerId || preferredPeerId) || "";
    $("qrModal").classList.add("show");
  }

  function showRoomQr() {
    $("qrModalTitle").textContent = "Room Code";
    const container = $("qrcodeContainer");
    container.innerHTML = "";
    new QRCode(container, { text: roomCode || "", width: 256, height: 256 });
    $("qrCodeText").textContent = roomCode || "";
    $("qrModal").classList.add("show");
  }

  function closeQR() {
    $("qrModal").classList.remove("show");
    $("qrcodeContainer").innerHTML = "";
  }

  function openQRScanner(mode) {
    if (html5QrCode) { try { html5QrCode.stop(); html5QrCode.clear(); } catch(_) {} }
    qrScannerMode = mode; // "direct" | "room"
    qrScanLocked = false;
    $("qrScannerTitle").textContent = `Scan ${mode === "direct" ? "Peer" : "Room"} QR Code`;
    $("qrScannerModal").classList.add("show");
    html5QrCode = new Html5Qrcode("qr-reader");
    html5QrCode.start(
      { facingMode: "environment" },
      { fps: 10, qrbox: { width: 250, height: 250 } },
      (decodedText) => {
        if (qrScanLocked) return;
        qrScanLocked = true;

        if (qrScannerMode === "direct") {
          $("remotePeerIdInput").value = decodedText;
          closeQRScanner(); // auto-close for direct only
          closeQR();
          connectDirect();
        } else {
          $("roomCodeInput").value = decodedText;
          // do not auto close for room; just attempt join once
          joinRoom();
          // allow user to keep the scanner open if they want to rescan
          setTimeout(() => { qrScanLocked = false; }, 1000);
        }
      },
      (errMsg) => { /* ignore scan errors */ }
    ).catch((err) => {
      console.error("QR start error:", err);
      notify("Camera error.", "error");
    });
  }

  function closeQRScanner() {
    const modal = $("qrScannerModal");
    if (!modal.classList.contains("show")) return;
    const stop = async () => {
      if (html5QrCode) {
        try { await html5QrCode.stop(); } catch(_) {}
        try { await html5QrCode.clear(); } catch(_) {}
        html5QrCode = null;
      }
    };
    stop().finally(() => {
      modal.classList.remove("show");
      const reader = $("qr-reader");
      if (reader) reader.innerHTML = "";
    });
  }
  // ---------- End of continuation ----------
</script>
</body>
</html>

